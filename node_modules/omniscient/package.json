{
  "name": "omniscient",
  "version": "2.1.0",
  "description": "A library providing an abstraction for React components for passing the same data structure through the entire component flow using cursors and immutable data structures.",
  "main": "component.js",
  "directories": {
    "example": "example"
  },
  "dependencies": {
    "extend-object": "^1.0.0",
    "lodash.isequal": "^3.0.0",
    "lodash.pick": "^3.0.0"
  },
  "peerDependencies": {
    "react": ">=0.12.0 || 0.13.0-beta.1"
  },
  "devDependencies": {
    "browserify": "^8.1.1",
    "browserify-shim": "^3.8.2",
    "chai": "^1.9.2",
    "derequire": "^1.2.0",
    "immstruct": "^1.0.0",
    "immutable": "^3.0.2",
    "jsdom": "^3.1.0",
    "mocha": "^2.0.1",
    "react": "^0.12.2",
    "uglify-js": "^2.4.15"
  },
  "scripts": {
    "test": "mocha -R spec tests/**-test.js",
    "test-watch": "mocha -G -w -R min tests/**-test.js",
    "dist": "node makeBundle.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/omniscientjs/omniscient.git"
  },
  "keywords": [
    "quiescent",
    "react",
    "immutable"
  ],
  "browserify-shim": {
    "react": "global:React"
  },
  "author": {
    "name": "@torgeir,@mikaelbr"
  },
  "license": "mit",
  "bugs": {
    "url": "https://github.com/omniscientjs/omniscient/issues"
  },
  "homepage": "https://github.com/omniscientjs/omniscient",
  "readme": "Omniscient [![NPM version][npm-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Dependency Status][depstat-image]][depstat-url] [![Gitter][gitter-image]][gitter-url]\n=========\n\n<img src=\"https://raw.githubusercontent.com/torgeir/omniscient/master/omniscient_logo.png\" align=\"right\" width=\"150px\">\n> A library providing an abstraction for React components that allows for fast top-down rendering embracing immutable data. Using cursors into immutable data structures, components can easily swap their own piece of data inside the larger immutable data structure. As data is immutable, re-rendering can be fast.\n\n> Omniscient pairs the simplicity of [Quiescent](https://github.com/levand/quiescent) with\nthe cursors of [Om](https://github.com/swannodette/om), for js, using\n[Immutable.js](https://github.com/facebook/immutable-js).\n\n### Overview\n\n- top-down rendering of components (one way data flow)\n- favors immutable data (with Immutable.js)\n- encourages small, composable components, and shared functionality through mixins\n- components only deal with their own piece of data\n- components can change their data, via cursors (without knowing where their data resides in the outer immutable data structure)\n- easily listen for changes across your data structure and trigger re-render\n- immutable data can give even faster re-renders than with pure React, as React can be prevented from even considering to re-render component trees with unchanged data\n- efficient, centrally defined `shouldComponentUpdate`\n\n\nA more detailed description of Omniscient's rationale can be found in the [documentation](http://omniscientjs.github.io/documentation). An introductory article can be found in the [wiki](https://github.com/omniscientjs/omniscient/wiki/Simpler-UI-Reasoning-with-Unidirectional-Dataflow-and-Immutable-Data).\n\n**Note:** Omniscient pre `v2.0.0` is for React pre `v0.12.0`. React `v0.12.0` had [breaking changes](https://github.com/facebook/react/blob/master/CHANGELOG.md#breaking-changes), and the API of Omniscient\nhad to change accordingly. See the [v1.3.1 tag](https://github.com/omniscientjs/omniscient/tree/v1.3.1) for Omniscient with React `v0.11.0` support.\n\n### Cursors\n\nWith cursors, components can have the outer immutable structure swapped when a component's data is changed. A re-render can be triggered, but only component trees referencing data affected by the change will actually be re-rendered. This means that if you don't pass any data (cursor or non-cursor property) to a component, this component won't be re-rendered. This could affect shallow parent components. Such a component could have a [`shouldComponentUpdate` that always return true](https://github.com/omniscientjs/omniscient#overriding-iscursor-and-isequalcursor). This will make the component always re-render.\n\nIf you pass in a single cursor, this is added to the `props.cursor` property, where `props` is what you get passed to your component.\n\n```js\nvar React     = require('react'),\n    immstruct = require('immstruct'),\n    component = require('omniscient');\n\nvar NameInput = component(function (props) {\n  var onChange = function (e) {\n    props.cursor.update('name', function (name) {\n      return e.currentTarget.value;\n    });\n  };\n  return React.DOM.input({ value: props.cursor.get('name'), onChange: onChange });\n});\n\nvar Welcome = component(function (props) {\n  var guest = props.cursor.get('guest');\n  var name = guest.get('name') ? \", \" + guest.get('name') : \"\";\n  return React.DOM.p({}, props.cursor.get('greeting'), name, \"!\",\n                         NameInput(guest));\n});\n\nvar structure = immstruct({ greeting: 'Welcome', guest: { name: '' } });\n\nfunction render () {\n  React.render(\n    Welcome(structure.cursor()),\n    document.querySelector('.app'));\n}\n\nrender();\nstructure.on('swap', render);\n```\n*See [the running demo](http://omniscientjs.github.io/examples/#intro) on the examples page*\n\n[`immstruct`](https://github.com/omniscientjs/immstruct) is a simple wrapper for [`Immutable.js`](https://github.com/facebook/immutable-js) that ease triggering re-renders with Omniscient when the immutable data structure is replaced. `immstruct` is not a requirement for Omniscient, but makes a great fit.\n\nIf you are running the distributed file, not browserify, you have to use `omniscient` instead of `component` in all examples.\n\n### Reuseable mixins\n\nOmniscient is fully compatible with exising react components, and encourages reuse of your existing mixins.\n\n```js\nvar SelectOnRender = {\n  componentDidMount: function () {\n    this.getDOMNode().select();\n  }\n};\n\nvar FocusingInput = component(SelectOnRender, function (props) {\n  return React.DOM.input({ value: props.cursor.get('text') });\n});\n```\n\nYou can also share other commonly used functions through mixins.\n\n```js\nvar Props = {\n  swapProps: function (props) {\n    this.props.cursor.update(function (state) {\n      return state.mergeDeep(props);\n    };\n  }\n};\n\nvar SaveOnEdit = {\n  onEdit: function (e) {\n    this.swapProps({ text: e.currentTarget.value });\n  }\n};\n\nvar SavingFocusingInput = component([Props, SaveOnEdit, SelectOnRender],\n  function (props) {\n    return React.DOM.input({ value: props.cursor.get('text'), onChange: this.onEdit });\n  });\n```\n\n### Statics\n\nWhen you need to provide other data for your component than what its rendering is based off of, you pass statics. By default, changing a static's value does not result in a re-rendering of a component.\n\nStatics have a special place in your passed properties. To give a component statics, you need to pass an object literal with the `statics` property defined.\n\n```js\nvar log = console.log.bind(console);\n\nvar FocusingInput = component(SelectOnRender, function (props, statics) {\n  var onChange = statics.onChange || function () {};\n  return React.DOM.input({ value: props.cursor.get('text'), onChange: onChange });\n});\n\nvar SomeForm = component(function (props.cursor) {\n  return React.DOM.form({},\n                        FocusingInput({ cursor: props.cursor, statics: { onChange: log } }));\n});\n```\n\n#### Talking back from child to parent\n\nCommunicating information back to the parent component from a child component can be done by making an event emitter available as a static for your child component.\n\n```js\nvar Item = component(function (props, statics) {\n  var onClick = function () {\n    statics.channel.emit('data', props.cursor);\n  };\n  return React.DOM.li({ onClick: onClick },\n                      React.DOM.text({}, props.cursor.get('text')));\n});\n\n\n// In some other file\nvar events = new EventEmitter();\nvar mixins = {\n  componentDidMount: function () {\n    events.on('data', function (item) {\n      console.log('Hello from', item);\n      // use self.props.cursor if needed (self = bound this)\n    });\n  }\n}\n\nvar List = component(function (props) {\n  return React.DOM.ul({},\n                      props.cursor.toArray().map(function (item) {\n                        return Item({ cursor: item, statics: { channel: events } });\n                      });\n});\n```\n\n### Local State\n\nOmniscient allows for component local state. That is, all the usual react component methods are available on `this` for use through mixins. You are free to `this.setState({ .. })` for component local view state.\n\n### Omniscient and JSX\n\nDue to the way React works with elements, and the way JSX is compiled, the use of Omniscient with JSX slightly differs from the normal use case. Instead of referencing a component directly, you will have to reference its `jsx` property, that exposes the component's underlying React class:\n\n\n```js\nvar React     = require('react'),\n    component = require('omniscient');\n\nvar Welcome = component(function (props, statics) {\n  console.log(statics.foo); //=> 'bar'\n\n  return (\n    <h1>Hello, {props.cursor.deref()}</h1>\n  );\n});\n\nvar structure = immstruct({ name: 'Doc' });\n\nfunction render () {\n  var someStatics = { foo: 'bar' };\n\n  // Note the `.jsx` extension\n  React.render(\n    <Welcome.jsx name={structure.cursor('name')} statics={someStatics} />\n    document.body);\n}\n\nrender();\nstructure.on('swap', render);\n\nstructure.cursor('name').update(function ()Â {\n  return 'Doctor';\n});\n```\n\nYou can also do `.jsx` on a component level:\n\n```js\nvar Welcome = component(function (props, statics) {\n  /* same implementation */\n}).jsx;\n```\n\nOr, when requiring the component:\n\n```js\nvar Welcome = require('./welcome').jsx;\n```\n\n### Providing component keys\n\nFor correct merging of states and components between render cycles, React needs a `key` as part of the props of a component. With Omniscient, such a key can be passed as the first argument to the `component` function.\n\n```js\nvar Item = component(function (props) {\n  return React.DOM.li({}, React.DOM.text(props.cursor.get('text')));\n});\n\nvar List = component(function (props) {\n  return React.DOM.ul({},\n                      props.cursor.toArray().map(function (item, key) {\n                        return Item(key, item);\n                      });\n});\n```\n\n### Efficient shouldComponentUpdate\n\nOmniscient provides an [efficient default](https://github.com/omniscientjs/omniscient/blob/master/component.js) `shouldComponentUpdate` that works well with the immutable data structures of Immutable.js.\n\n#### Overriding shouldCompontentUpdate\n\nHowever, an individual component's `shouldComponentUpdate` can easily be changed through the use of mixins:\n\n```js\nvar ShouldComponentUpdateMixin = {\n  shouldComponentUpdate: function (newProps, newState) {\n    // your custom implementation\n    return true; // don't do this\n  };\n};\n\nvar InefficientAlwaysRenderingText = component(ShouldComponentUpdateMixin, function (props) {\n  return React.DOM.text(props.cursor.get('text'));\n});\n```\n\n#### Overriding the default shouldCompontentUpdate globally\n\nIf you want to override `shouldCompontentUpdate` across your entire project, you can do this by setting the `shouldCompontentUpdate` method from Omniscient.\n\n```js\ncomponent.shouldComponentUpdate = function (newProps, newState) {\n  // your custom implementation\n  return true; // don't do do this\n};\n\nvar InefficientAlwaysRenderingText = component(function (props) {\n  return React.DOM.text(props.cursor.get('text'));\n});\n```\n\n### Using Different Cursors than Immutable.js\n\n[Immutable.js](https://github.com/facebook/immutable-js) is used as an optional dependency per default\nas the cursor-check used in the provided `shouldCompontentUpdate` takes for granted that the cursors\nare Immutable.js cursors. You can easily override this by overriding two methods provided\nby Omniscient; `isCursor` and `isEqualCursor`.\n\n#### Overriding `isCursor` and `isEqualCursor`\n\n`isCursor` should return true if provided object is of cursor type.\n\n```js\nvar component = require('omniscient');\n\ncomponent.isCursor = function (potentialCursor) {\n  return potentialCursor instanceof MyCustomCursor;\n};\n```\n\n`isEqualCursor` should return true if two provided cursors are equal.\n\n```js\nvar component = require('omniscient');\n\ncomponent.isEqualCursor = function (oldCursor, newCursor) {\n  return oldCursor.unwrap() === newCursor.unwrap();\n};\n```\n\n### Immstruct\n\nImmstruct is not a requirement for Omniscient, and you are free to choose any other cursor implementation, or you can use Immutable.js directly.\n\nIf you are using something other than the cursors from Immutable.js, however, make sure to provide a custom implementation of `shouldComponentUpdate` for efficient rendering.\n\nSee [how to use immstruct](https://github.com/omniscientjs/immstruct/blob/master/README.md) for more information.\n\n### Debugging\n\nFor debugging purposes, Omniscient supports calling `component.debug([regexPattern])`. This enables logging on calls to `render` and `shouldComponentUpdate`.\n\nWhen debugging, you should give your component names. This way the output will be better traceable,\nand you can filter on components using regex.\n\n```js\nvar MyComponent = component('MyComponent', function () {\n  return React.DOM.text({}, 'I output logging information on .shouldComponentUpdate() and .render()');\n});\n\nReact.render(MyComponent('my-key'), document.body);\n```\n\n#### Filtering Debugging\n\nThe `component.debug` method takes an optional argument: `pattern`. This should be a regex\nused for matching a component name or key. This allows you to filter on both component and\ninstance of component:\n\n\n```js\ncomponent.debug(/mycomponent/i);\n\n// or by key:\ncomponent.debug(/my-key/);\n```\n\nSetting debug is a global change. If you want to be able to filter on multiple things and dig down\nfor finding errors, you can also use filtering in your browser inspector.\n\n---\n\n## Authors\n\n- [Mikael Brevik](https://github.com/mikaelbr) ([@mikaelbrevik](https://twitter.com/mikaelbrevik))\n- [Torgeir Thoresen](https://github.com/torgeir) ([@torgeir](https://twitter.com/torgeir))\n\n## Omniscient in the wild\n\n- [TodoMVC - Omniscient](https://github.com/jcranendonk/todomvc-omniscient/) by [jeroencranendonk-wf](https://github.com/jeroencranendonk-wf)\n\n## License\n\n[MIT License](http://en.wikipedia.org/wiki/MIT_License)\n\n[npm-url]: https://npmjs.org/package/omniscient\n[npm-image]: http://img.shields.io/npm/v/omniscient.svg?style=flat\n\n[travis-url]: http://travis-ci.org/omniscientjs/omniscient\n[travis-image]: http://img.shields.io/travis/omniscientjs/omniscient.svg?style=flat\n\n[depstat-url]: https://gemnasium.com/omniscientjs/omniscient\n[depstat-image]: http://img.shields.io/gemnasium/omniscientjs/omniscient.svg?style=flat\n\n[gitter-url]: https://gitter.im/omniscientjs/omniscient?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n[gitter-image]: https://badges.gitter.im/Join%20Chat.svg\n\n*Logo is composed by icons from [Iconmoon](http://www.icomoon.io)\nand [Picol](http://picol.org). Licensed under [CC BY 3.0](http://creativecommons.org/licenses/by/3.0/)*\n",
  "readmeFilename": "README.md",
  "_id": "omniscient@2.1.0",
  "_shasum": "f13f9e01603e69bcc73922499ee0db87eeab5f41",
  "_resolved": "git://github.com/Gozala/omniscient.git#c10cd20ddca6c71fcf852845114afac4afacd5b4",
  "_from": "omniscient@git://github.com/Gozala/omniscient.git#unboxing"
}
